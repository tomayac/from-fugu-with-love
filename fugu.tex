%%
%% This is file `sample-sigconf.tex',
%% generated with the docstrip utility.
%%
%% The original source files were:
%%
%% samples.dtx  (with options: `sigconf')
%% 
%% IMPORTANT NOTICE:
%% 
%% For the copyright see the source file.
%% 
%% Any modified versions of this file must be renamed
%% with new filenames distinct from sample-sigconf.tex.
%% 
%% For distribution of the original source see the terms
%% for copying and modification in the file samples.dtx.
%% 
%% This generated file may be distributed as long as the
%% original source files, as listed above, are part of the
%% same distribution. (The sources need not necessarily be
%% in the same archive or directory.)
%%
%% The first command in your LaTeX source must be the \documentclass command.

% \documentclass[sigconf]{acmart}
\documentclass[sigconf, anonymous]{acmart}
\usepackage[utf8]{inputenc}

%%
%% \BibTeX command to typeset BibTeX logo in the docs
\AtBeginDocument{%
  \providecommand\BibTeX{{%
    \normalfont B\kern-0.5em{\scshape i\kern-0.25em b}\kern-0.8em\TeX}}}

%% Rights management information.  This information is sent to you
%% when you complete the rights form.  These commands have SAMPLE
%% values in them; it is your responsibility as an author to replace
%% the commands and values with those provided to you when you
%% complete the rights form.
\setcopyright{acmcopyright}
\copyrightyear{2020}
\acmYear{2020}
\acmDOI{10.1145/1122445.1122456}

%% These commands are for a PROCEEDINGS abstract or paper.
\acmConference[Woodstock '18]{Woodstock '18: ACM Symposium on Neural
  Gaze Detection}{June 03--05, 2018}{Woodstock, NY}
\acmBooktitle{Woodstock '18: ACM Symposium on Neural Gaze Detection,
  June 03--05, 2018, Woodstock, NY}
\acmPrice{15.00}
\acmISBN{978-1-4503-XXXX-X/18/06}


%%
%% Submission ID.
%% Use this when submitting an article to a sponsored event. You'll
%% receive a unique submission ID from the organizers
%% of the event, and this ID should be used as the parameter to this command.
%%\acmSubmissionID{123-A56-BU3}

%%
%% The majority of ACM publications use numbered citations and
%% references.  The command \citestyle{authoryear} switches to the
%% "author year" style.
%%
%% If you are preparing content for an event
%% sponsored by ACM SIGGRAPH, you must use the "author year" style of
%% citations and references.
%% Uncommenting
%% the next command will enable that style.
%%\citestyle{acmauthoryear}

%%
%% end of the preamble, start of the body of the document source.
\begin{document}

%%
%% The "title" command has an optional parameter,
%% allowing the author to define a "short title" to be used in page headers.
\title{From Fugu With Love: New Capabilities for the Web}

%%
%% The "author" command and its associated commands are used to define
%% the authors and their affiliations.
%% Of note is the shared affiliation of the first two authors, and the
%% "authornote" and "authornotemark" commands
%% used to denote shared contribution to the research.
\author{Thomas Steiner}
\author{Pete LePage}
\author{Thomas Nattestad}
\author{Alex Russell}
\author{Dominick Ng}
\author{Rory McClelland}
\email{tomac@google.com}
\affiliation{
  \institution{Google LLC}
  \streetaddress{1600 Amphitheatre Parkway}
  \city{Mountain View}
  \state{CA 94043}
}

%%
%% By default, the full list of authors will be used in the page
%% headers. Often, this list is too long, and will overlap
%% other information printed in the page headers. This command allows
%% the author to define a more concise list
%% of authors' names for this purpose.
% \renewcommand{\shortauthors}{Trovato and Tobin, et al.}

%%
%% The abstract is a short summary of the work to be presented in the
%% article.
\begin{abstract}
With this demo, we will show at the example of a greeting card web application
how new and upcoming browser capabilities can progressively enhance
this application so that it remains useful on all modern browsers,
but delivers a truly stunning experience on browsers that support new web capabilities
like native file system access, system clipboard access, contacts retrieval,
periodic background sync, screen wake lock, sharing features, and many more.
\end{abstract}

%%
%% The code below is generated by the tool at http://dl.acm.org/ccs.cfm.
%% Please copy and paste the code instead of the example below.
%%
\begin{CCSXML}
<ccs2012>
<concept>
<concept_id>10002951.10003260.10003282</concept_id>
<concept_desc>Information systems~Web applications</concept_desc>
<concept_significance>500</concept_significance>
</concept>
<concept>
<concept_id>10002951.10003260.10003300.10003302</concept_id>
<concept_desc>Information systems~Browsers</concept_desc>
<concept_significance>500</concept_significance>
</concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Information systems~Web applications}
\ccsdesc[500]{Information systems~Browsers}

%%
%% Keywords. The author(s) should pick words that accurately describe
%% the work being presented. Separate the keywords with commas.
\keywords{Progressive Web Apps, Web \textsc{api}s, Web Incubator Community Group}

%%
%% This command processes the author and affiliation and title
%% information and builds the first part of the formatted document.
\maketitle

\section{Introduction and Background}

\subsection{The App Gap}

Modern web browsers provide a solid foundation of capabilities
that allow for the creation of impressive web applications.
Those capabilities have enabled new experiences on the web
that were never thought possible on what initially started as
a~global information space of linked documents.
WebAssembly (Wasm) is enabling new classes of games and productivity apps,
Web Real-Time Communication (Web\textsc{rtc}) enables new ways to communicate,
and service workers allow developers to create reliably fast web experiences
almost regardless of network conditions.
However, there are some capabilities, like file system access,
raw clipboard access, background app refresh, and more,
that are available to native platforms like Android or i\textsc{os},
but that are not available to the web platform.
These missing capabilities mean some types of apps cannot be delivered on the web,
or that these apps are less useful.
In colloquial terms, this is sometimes referred to as the \textit{app gap}.

\subsection{Using Web Technologies, But Not the Web}

To cope, some developers only build native apps---that is,
do not build for the web in the first place---or
use wrappers like Apache Cordova\footnote{Apache Cordova: \url{https://cordova.apache.org/}}
on mobile or Electron\footnote{Electron: \url{https://electronjs.org/}} on desktop
to access the underlying capabilities of the device,
while still building \textit{with} the web technologies
\textsc{html}, \textsc{css}, and \textsc{js}.
This is not without risk from a~security point of view~\cite{carettoni17,luo11},
and also suboptimal for users who, apart from the application code,
additionally need to download the wrapper code---for each application separately.
We argue that instead web developers should have access
to the capabilities they need to create great web experiences,
and we want to support them as they do by collaborating in the \textit{capabilities project}.

\subsection{The Capabilities Project, Or Project Fugu}

In the context of the capabilities project, we want to enable web apps
to do anything native apps can, by exposing the capabilities of native platforms
to the web platform, while maintaining user security, privacy, trust,
and other core tenets of the web.
Giving developers these new tools will empower the open web
as a place where any experience can be created,
and make it a~first class platform for developing apps that run on any browser,
with any operating system, and on any device.
We design and develop these new capabilities in an open and transparent way
in the \textsc{w3c}'s Web Incubator Community
Group\footnote{\textsc{wicg}: \url{https://wicg.io/}} (\textsc{wicg})
using the existing open web platform standards processes
while getting early feedback from developers and other browser vendors
as we iterate on the design to ensure its interoperability.

The capabilities project is a~truly cross-company effort,
with contributors from Google, Intel, and Microsoft.
All monthly meeting notes are publicly
available\footnote{Project Fugu notes: \url{https://bit.ly/fugu-sync}}
and the conference calls are open for anyone to join.

We have identified and prioritized an initial set of capabilities
we heard partner demand for and that we see as critical to closing the gap
between web and native, and have already started work on a handful of them.
People interested in the list can review it by searching the Chromium bug database
for bugs that are tagged with the label
\texttt{proj-fugu}.\footnote{Project Fugu bugs: \url{https://bit.ly/fugu-bugs}}
Fugu is a pufferfish that is considered a delicacy, however,  
if not carefully prepared, can be lethally poisonous. 
This analogy works quite well with many of the capabilities we deal with,
hence the code name \textit{project fugu}.
We have outlined our vision for a~more capable web in a~blog post~\cite{lepage18}
on the Chromium blog and invite interested parties to follow along the project's progress
on the dedicated landing
page.\footnote{Project Fugu landing page: \url{https://developers.google.com/web/updates/capabilities}}

\subsection{The Fugu Process}

We have developed a process to make it possible to design and develop
new web platform capabilities that meet the needs of developers quickly,
in the open, and most importantly, work within the existing standards process.
Developer feedback is critical to help us ensure we are shipping the right features,
but it is easier to change course early in the process.
It is worth noting that many ideas never make it past an explainer or origin trial stage.
\textit{Not} shipping a feature because it does not solve the developer need is fine.
We want to highlight that this process does \textit{not} replace the Blink launch
process,\footnote{Blink launch process: \url{https://www.chromium.org/blink/launching-features}}
both go hand in hand together.
The fugu process, depicted in \autoref{fig:fuguprocess}, consists of the following steps:

\begin{enumerate}  
  \item Identify the developer need:
  
  The first step is to identify and understand the developer need.
  What is the developer trying to accomplish?
  How are they doing it today? And what and whose problems or frustrations
  are fixed by this new capability? Typically, these come in as feature request
  from developers, frequently via bugs filed on \url{bugs.chromium.org}.

  \item Create an explainer:

  After identifying the need for a new capability, create an explainer,
  essentially a~design document that is meant to explain the problem,
  along with sample code showing how the \textsc{api} might work.
  The explainer is a living document that will go through heavy iteration
  as the new capability evolves.

  \item Get feedback and iterate on the explainer:

  Once the explainer has a reasonable level of clarity,
  it is time to publicize it, to solicit feedback, and iterate on the design.
  This is an opportunity to verify the new capability meets the needs of developers
  and works in a way that they expect. This is also an opportunity to gather
  public support and verify that there really is a need for this capability.

  \item Move the design to a specification and iterate:
  
  Once the explainer is in a good state,
  the design work transitions into a formal specification,
  working with developers and other browser vendors to iterate and improve on the design.
  Then, once the design starts to stabilize, we typically use an
  origin trial\footnote{Origin Trial: \url{http://googlechrome.github.io/OriginTrials/explainer.html}}
  to experiment with the implementation.
  Origin trials allow developers to try new features with real users,
  and give feedback on the implementation.
  This real world feedback helps shape and validate the design,
  ensuring we get it right, before it becomes a~standard.

  \item Ship it:

  Finally, once the origin trial is complete, the spec has been finalized,
  and all of the other launch steps have been completed, it is time to ship it to stable.  
\end{enumerate}

\begin{figure}[hbt]
  \includegraphics[width=\columnwidth]{capabilities-process.jpg}
  \caption{The Capabilities Process}
  \label{fig:fuguprocess}
\end{figure}


\subsection{Permissions}

Some of the capabilities we work on are potentially harmful for users
if not handled appropriately (we recall the code name of this project).
In a~position paper~\cite{russell18} presented at the \textsc{w3c} Permissions Workshop,
we have thus outlined our standpoints regarding evolving the current permission model.
Briefly, we propose the following steps to be taken:

\begin{itemize}
  \item Permission-requesting \textsc{api}s need to introduce the ability for
    developers to register interest in a~capability before ever being allowed to prompt users
    and to be called back when the situation changes in their favor.
  \item Since different web \textsc{api}s currently have disparate ways to signal
    a~developer's intent to use them, permissions requests should be centralized
    on a~single method~\cite{yasskin17} to enable the introduction
    of better user controls and bring much needed developer consistency.
  \item The Permissions \textsc{api}~\cite{lamouri19} should be extended with a revoke method,
    so developers are able to ensure their applications operate with least-privilege.
  \item The Web Application Manifest should be extended to include fields
    which allow sites to identify to the runtime a maximum set of permissions.
    Requests for permissions not included in this list should fail.
\end{itemize}

\subsection{Access to Powerful Web Platform Features}

Allowing users to control which sites are able to access powerful \textsc{api}s
is crucial for maintaining the security and privacy properties of the web.
The impact of restrictions on the developer ergonomics and user utility
of the \textsc{api} and the web platform overall must also be considered.
The following general principles~\cite{ng19} summarize the overall approach of the Chromium project
to evaluating how powerful new features should be controlled on the web:

\begin{itemize}
  \item Access to powerful APIs should be available to the entire web platform of secure contexts,
    with control managed exclusively by choosers, prompts,
    or other user consent \textsc{ux} at time-of-use.
  \item \textsc{api}-specific restrictions on the scope of access may also be used
    to guard against potential abuse.
  \item Usage of powerful \textsc{api}s should be clearly disclosed to users,
    ideally using a central hub that offers users control over what sites
    can use which capabilities.
  \item Installing a~web app is associated with persistence,
    and thus persistent and/or background access to powerful \textsc{api}s
    may only be granted (possibly subject to additional requirements) to installed web apps.
    Non-installed sites may still request and be granted permission to use powerful \textsc{api}s,
    but should not have their access persisted.
  \item Installation or engagement alone should not act as a vote of trust
    for either granting access or enabling the ability to ask for access to powerful \textsc{api}s.
    Separately, efforts should be made to curtail the existing persistency
    on the web platform outside of installed web apps, \textit{e.g.},\ time-limiting permission grants,
    more aggressively expiring cookies, and restricting background task execution.
\end{itemize}

\section{Prior Art}

This is not the first attempt at making the web a~powerful application platform.
Below, we list three platforms that went to market with this promise.
While there are more, these three can serve as representative examples of the genre.

\subsection{Chrome Apps}

In 2013, Chrome Apps~\cite{kay13} promised to bring together the speed, security,
and flexibility of the modern web with the powerful functionality
previously only available with software installed on devices. 
Chrome Apps were designed to work offline, were capable of running in stand-alone windows,
could be launched directly from the desktop,
could connect to the cloud, supported desktop notifications,
and could interact with \textsc{usb}, Bluetooth and other devices connected to a~desktop,
including digital cameras.
They were kept updated automatically and synced the state of apps
to all desktop devices the user signed in to.
Chrome Apps could use a~set of proprietary \texttt{chrome.*}
\textsc{api}s.\footnote{\texttt{chrome.*}
\textsc{api}s: \url{https://developer.chrome.com/apps/api_index}}
After three years, Chrome Apps were deprecated in August
2013\footnote{Chrome Apps Deprecation: \url{https://blog.chromium.org/2016/08/from-chrome-apps-to-web.html}}
The capabilities project is a~direct successor to Chrome Apps,
in fact, Progressive Web Apps built using Fugu \textsc{api}s
are one of the recommended migration
strategies.\footnote{Transitioning from Chrome Apps: \url{https://developers.chrome.com/apps/migration}}

\subsection{Palm web\textsc{os}}

Palm web\textsc{os}\footnote{Palm web\textsc{os} announcement:
\url{https://web.archive.org/web/20090117111808/http://investor.palm.com/releasedetail.cfm?ReleaseID=358392}}
was invented exclusively for mobile use.
It recognized that users wanted their people, calendars, and information to move with them,
wherever they were, wirelessly, as opposed to being bound to a personal computer.
At its core, web\textsc{os} leverages industry-standard technologies,
including web technologies such as \textsc{css}, \textsc{xhtml}, and \textsc{js}.
It changed owners several times and lives on as an open-source
project\footnote{web\textsc{os} open-psource project: \url{https://www.webosose.org/}}
powering smart devices.

\subsection{Firefox \textsc{os}}

Firefox \textsc{os}, also known as
Boot~2~Gecko,\footnote{Boot 2 Gecko: \url{https://developer.mozilla.org/en-US/docs/Archive/B2G_OS}}
first commercially released in 2013,
is a~discontinued open-source operating system
designed by Mozilla and external contributors.
It was based on the rendering engine of the Firefox web browser, Gecko,
and on the Linux kernel.
The operating system was capable of running web applications directly
or those installed from an application marketplace.
The applications used standards like JavaScript and \textsc{html}5,
and web \textsc{api}s that could communicate directly with the underlying hardware.
A~fork of Firefox \textsc{os} gains traction under the name of
Kai\textsc{os},\footnote{Kai\textsc{os}: \url{https://www.kaiostech.com/}}
especially on feature phones in emerging markets.

\section{Demo Description}

\subsection{Core Contributions and Intended Audience}

Back in March 2003, Nick Finck and Steve Champeon stunned the web design world
with the concept of progressive enhancement~\cite{champeon03},
a~strategy for web design that emphasizes core webpage content first,
and that then progressively adds more nuanced and technically rigorous layers
of presentation and features on top of the content.
While in 2003, progressive enhancement was about using at the time modern \textsc{css} features,
unobtrusive JavaScript, and even Scalable Vector Graphics,
progressive enhancement in 2020 is about using modern browser capabilities.

With this demo, we will show at the example of a greeting card web application
how new and upcoming browser capabilities can progressively enhance
this application so that it remains useful on all modern browsers,
but delivers a truly stunning experience on browsers that support capabilities
like native file system access, system clipboard access, contacts retrieval,
periodic background sync, screen wake lock, sharing features, and many more.

The target audience are web developers, browser engineers,
and people involved in the \textsc{w3c} standards process.

\subsection{Baseline Application}

Progressive Web Applications (\textsc{pwa}s) are a type of application software
delivered through the web, built using common web technologies
including \textsc{html}, \textsc{css}, and \textsc{js}.
They are intended to work on any platform that uses a standards-compliant browser.
As such, we will start with a simple drawing web application
that serves as the baseline greeting card app that is offline-enabled,
can be added to the user's home screen, \textit{etc.},
and step-by-step add new browser capabilities
as progressive enhancements that are dynamically offered on supporting browsers.
We note that the design of this application is by no means final.

\subsection{Web Share \textsc{api} Support}

Creating the most amazing greeting cards is boring if there is no one out to appreciate them.
We thus add a~feature that allows the user to share their drawings with the world.
The Web Share \textsc{api}~\cite{giuca2017webshare} allows for sharing of files
using the native device's share mechanism.
\autoref{fig:share} shows the user initiating a~share of a drawing on an Android device.
Both the native Google Hangouts app as well as the native Facebook app offer itself
as share targets.
Through the Web Share target \textsc{api}, the greeting card app itself can become a~share target
that one can share images to, for example, from the native photo gallery app.

\begin{figure}[hbt]
  \includegraphics[width=0.3\columnwidth]{share.png}
  \caption{Web Share \textsc{api}}
  \label{fig:share}
\end{figure}

\subsection{Native File System \textsc{api} Support}

Drawing everything from scratch is hard.
We thus add a~feature that allows the user to import a local image into the application.
\autoref{fig:file} shows the file import dialog where, after granting access,
the user can open a local image file and add it to their drawing.
Later, they can also save their creation top disk.
Both operations are enabled through the Native File System Access \textsc{api}~\cite{kruisselbrink19}
and not to be confused with legacy workarounds that required uploading a local file to a server
and downloading a~copy.

\begin{figure}[hbt]
  \includegraphics[width=0.5\columnwidth]{file.png}
  \caption{Native File System Access \textsc{api}}
  \label{fig:file}
\end{figure}

\subsection{Contact Access \textsc{api} Support}

At times it can be hard to correctly type a~greeting card recipient's name,
for example, when it is written in a~different script
that the present keyboard layout does not support.
We add a~feature that allows users to pick one (or multiple) of their local contacts
and add their names to the greeting card message.
This is a~one-off operation facilitated by the Contact Picker \textsc{api}~\cite{beverloo19},
no continuous access to the contacts is granted.

\subsection{Clipboard \textsc{api} Support}

Occasionally users might want to paste a~picture from another app into the greeting card app,
or copy a drawing from the greeting card app into another app.
We add a~feature that allows users to copy and paste images from and to the app.
The Clipboard \textsc{api}~\cite{kacmarcik19} allows for the asynchronous copying and pasting
of image data (currently limited to Portable Network Graphics images).

\subsection{Badging \textsc{api} Support}

If the greeting cards app is installed on a~user's device,
it will have an icon on their home screen.
This icon can be used to convey fun information on the icon badge
like the number of brushstrokes a~given drawing has taken.
The Badging \textsc{api}~\cite{giuca19} enables apps to set a~numeric badge on the app icon.

\subsection{Further \textsc{api}s Support}

The demo will showcase a number of other \textsc{api}s, namely the
Shape Detection \textsc{api} to detect shapes like faces,
the Wake Lock  \textsc{api} to keep the screen awake
while the user waits for drawing inspiration, 
the Periodic Background Sync  \textsc{api} to surprise the user
with a~new greeting card template each day,
the Idle Detection \textsc{api} to clear the greeting card
when the user is no longer interacting with the application
(for example, when it is running in a~public kiosk setup),
and ultimately the File Handling \textsc{api}, which allows the greeting card app
to register as a~file handler so image files can be opened 
with the app directly via the operating system's file explorer.

\section{Conclusions}

We hope to gather feedback on these proposed features from the conference attendees,
as well as trigger conversations about future challenges around
permissions, security, and browser compatibility,
and invite interested parties to learn more about Project Fugu.

\bibliographystyle{ACM-Reference-Format}
\bibliography{fugu}

\appendix

\section{Demo Requirements}

The demo is publicly available at \url{https://glitch.com/~fugu-greetings},
where it can either be explored directly,
or where its source code can be inspected and cloned.
We recommend running the demo in the latest Chrome
Canary\footnote{Chrome Canary: \url{https://www.google.com/chrome/canary/}}
or Edge
Canary\footnote{Edge Canary: \url{https://www.microsoftedgeinsider.com/en-us/download}}
browsers.
Since this demo is about bleeding edge web \textsc{api}s,
some browser runtime flags need to be set (replace \texttt{chrome://}
with \texttt{edge://} on Edge):

\begin{itemize}
  \item \url{chrome://flags/#native-file-system-api}
  \item \url{chrome://flags/#enable-experimental-web-platform-features}  
  \item \url{chrome://flags/#periodic-background-sync}
\end{itemize}

\end{document}
\endinput
